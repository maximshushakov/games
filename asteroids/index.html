<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <title>Games: Graphs Playground</title>
</head>
<body>
  <canvas width="400" height="400"></canvas>

  <script type="module">
    import { Box } from '../pong/entities.js';
    import Gamepad from '../pong/gamepad.js';
    const player = new Box();
    const gamepad = Gamepad.create();


    const canvas = document.querySelector('canvas');
    // const ctx = canvas.getContext("2d");
    const gl = canvas.getContext("webgl2");

    const v_shader_update = `#version 300 es
      precision mediump float;

      uniform float u_TimeDelta;
      uniform sampler2D u_RgNoise;
      uniform vec2 u_Gravity;
      uniform vec2 u_Origin;
      uniform float u_MinTheta;
      uniform float u_MaxTheta;
      uniform float u_MinSpeed;
      uniform float u_MaxSpeed;

      in vec2 i_Position;
      in float i_Age;
      in float i_Life;
      in vec2 i_Velocity;

      out vec2 v_Position;
      out float v_Age;
      out float v_Life;
      out vec2 v_Velocity;

      void main() {
        if (i_Age >= i_Life) {
          ivec2 noise_coord = ivec2(gl_VertexID % 512, gl_VertexID / 512);
          vec2 rand = texelFetch(u_RgNoise, noise_coord, 0).rg;
          float theta = u_MinTheta + rand.r*(u_MaxTheta - u_MinTheta);
          float x = cos(theta);
          float y = sin(theta);
          v_Position = u_Origin;
          v_Age = 0.0;
          v_Life = i_Life;
          v_Velocity = vec2(x, y) * (u_MinSpeed + rand.g * (u_MaxSpeed - u_MinSpeed));
        } else {
          v_Position = i_Position + i_Velocity * u_TimeDelta;
          v_Age = i_Age + u_TimeDelta;
          v_Life = i_Life;
          v_Velocity = i_Velocity + u_Gravity * u_TimeDelta;
        }
      }
    `;

    const f_shader_empty = `#version 300 es
      precision mediump float;
      in float v_Age;
      void main() { discard; }
    `;

    const v_shader = `#version 300 es
      precision mediump float;

      in vec2 i_Position;
      in float i_Age;
      in float i_Life;
      in vec2 i_Velocity;

      out float v_Age;
      out float v_Life;

      void main() {
        gl_PointSize = 1.0; //+ 100.0 * (1.0 - i_Age/i_Life);
        gl_Position = vec4(i_Position, 0.0, 1.0);
      }
    `;

    const f_shader = `#version 300 es
      precision mediump float;

      in float v_Age;
      in float v_Life;

      out vec4 o_FragColor;

      void main() {
        float t =  1.0 - v_Age/v_Life;
        o_FragColor = vec4(1.0, 1.0, 1.0, .2);
      }
    `;

    const createShader = (type, source) => {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (success) {
        return shader;
      }
      console.log(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
    }

    const vertexShader1 = createShader(gl.VERTEX_SHADER, v_shader_update);
    const vertexShader2 = createShader(gl.VERTEX_SHADER, v_shader);
    const fragmentShader1 = createShader(gl.FRAGMENT_SHADER, f_shader_empty);
    const fragmentShader2 = createShader(gl.FRAGMENT_SHADER, f_shader);

    const createGLProgram = (gl, vertexShader, fragmentShader, transform_feedback_varyings) => {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      if (transform_feedback_varyings != null) {
        gl.transformFeedbackVaryings(
          program,
          transform_feedback_varyings,
          gl.INTERLEAVED_ATTRIBS);
      }
      gl.linkProgram(program);

      const success = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (success) {
        return program;
      }

      console.log(gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
    }

    const randomRGData = (size_x, size_y) => {
      const d = [];
      for (var i = 0; i < size_x * size_y; ++i) {
        d.push(Math.random() * 255.0);
        d.push(Math.random() * 255.0);
      }
      return new Uint8Array(d);
    }

    const initialParticleData = (num_parts, min_age, max_age) => {
      var data = [];
      for (var i = 0; i < num_parts; ++i) {
        // position
        data.push(0.0);
        data.push(0.0);

        var life = min_age + Math.random() * (max_age - min_age);
        // set age to max. life + 1 to ensure the particle gets initialized
        // on first invocation of particle update shader
        data.push(life + 1);
        data.push(life);

        // velocity
        data.push(0.0);
        data.push(0.0);
      }
      return data;
    }

    /*
  This is a helper function used by the main initialization function.
  It sets up a vertex array object based on the given buffers and attributes
  they contain.
  If you're familiar with VAOs, following this should be easy.
  */
function setupParticleBufferVAO(gl, buffers, vao) {
  gl.bindVertexArray(vao);
  for (var i = 0; i < buffers.length; i++) {
    var buffer = buffers[i];
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer_object);
    var offset = 0;
    for (var attrib_name in buffer.attribs) {
      if (buffer.attribs.hasOwnProperty(attrib_name)) {
        /* Set up vertex attribute pointers for attributes that are stored in this buffer. */
        var attrib_desc = buffer.attribs[attrib_name];
        gl.enableVertexAttribArray(attrib_desc.location);
        gl.vertexAttribPointer(
          attrib_desc.location,
          attrib_desc.num_components,
          attrib_desc.type,
          false,
          buffer.stride,
          offset);
        /* we're only dealing with types of 4 byte size in this demo, unhardcode if necessary */
        var type_size = 4;

        /* Note that we're cheating a little bit here: if the buffer has some irrelevant data
           between the attributes that we're interested in, calculating the offset this way
           would not work. However, in this demo, buffers are laid out in such a way that this code works :) */
        offset += attrib_desc.num_components * type_size;

        if (attrib_desc.hasOwnProperty("divisor")) { /* we'll need this later */
          gl.vertexAttribDivisor(attrib_desc.location, attrib_desc.divisor);
        }
      }
    }
  }
  gl.bindVertexArray(null);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
}

/*
 * The main initialization function.
 * Returns an object representing a particle system with the given parameters.
 * `gl' shall be a valid WebGL 2 context.
 * `particle_birth_rate' defines the number of particles born per millisecond.
 * `num_particles' shall be the total number of particles in the system.
 * `min_age' and `max_age' define the allowed age range for particles, in
 *     seconds. No particle will survive beyond max_age, and every particle
 *     is guaranteed to remain alive for at least min_age seconds.
 * `min_theta' and `max_theta' define the range of directions in which new
 *     particles are allowed to be emitted.
 * `min_speed' and `max_speed' define the valid range of speeds for new
 *     particles.
 * `gravity' is a 2-vector representing a force affecting all particles at all
 *     times.
 */
function init(
    gl,
    num_particles,
    particle_birth_rate,
    min_age,
    max_age,
    min_theta,
    max_theta,
    min_speed,
    max_speed,
    gravity) {
  /* Do some parameter validation */
  if (max_age < min_age) {
    throw "Invalid min-max age range.";
  }
  if (max_theta < min_theta ||
      min_theta < -Math.PI ||
      max_theta > Math.PI) {
    throw "Invalid theta range.";
  }
  if (min_speed > max_speed) {
    throw "Invalid min-max speed range.";
  }

  /* Create programs for updating and rendering the particle system. */
  var update_program = createGLProgram(
    gl,
    vertexShader1,
    fragmentShader1,
    [
      "v_Position",
      "v_Age",
      "v_Life",
      "v_Velocity",
    ]);
  var render_program = createGLProgram(
    gl,
    vertexShader2,
    fragmentShader2,
    null);

  /* Capture attribute locations from program objects. */
  var update_attrib_locations = {
    i_Position: {
      location: gl.getAttribLocation(update_program, "i_Position"),
      num_components: 2,
      type: gl.FLOAT
    },
    i_Age: {
      location: gl.getAttribLocation(update_program, "i_Age"),
      num_components: 1,
      type: gl.FLOAT
    },
    i_Life: {
      location: gl.getAttribLocation(update_program, "i_Life"),
      num_components: 1,
      type: gl.FLOAT
    },
    i_Velocity: {
      location: gl.getAttribLocation(update_program, "i_Velocity"),
      num_components: 2,
      type: gl.FLOAT
    }
  };
  var render_attrib_locations = {
    i_Position: {
      location: gl.getAttribLocation(render_program, "i_Position"),
      num_components: 2,
      type: gl.FLOAT
    }
  };

  /* These buffers shall contain data about particles. */
  var buffers = [
    gl.createBuffer(),
    gl.createBuffer(),
  ];
  /* We'll have 4 VAOs... */
  var vaos = [
    gl.createVertexArray(), /* for updating buffer 1 */
    gl.createVertexArray(), /* for updating buffer 2 */
    gl.createVertexArray(), /* for rendering buffer 1 */
    gl.createVertexArray() /* for rendering buffer 2 */
  ];

  /* this has information about buffers and bindings for each VAO. */
  var vao_desc = [
    {
      vao: vaos[0],
      buffers: [{
        buffer_object: buffers[0],
        stride: 4 * 6,
        attribs: update_attrib_locations
      }]
    },
    {
      vao: vaos[1],
      buffers: [{
        buffer_object: buffers[1],
        stride: 4 * 6,
        attribs: update_attrib_locations
      }]
    },
    {
      vao: vaos[2],
      buffers: [{
        buffer_object: buffers[0],
        stride: 4 * 6,
        attribs: render_attrib_locations
      }],
    },
    {
      vao: vaos[3],
      buffers: [{
        buffer_object: buffers[1],
        stride: 4 * 6,
        attribs: render_attrib_locations
      }],
    },
  ];

  /* Populate buffers with some initial data. */
  var initial_data =
    new Float32Array(initialParticleData(num_particles, min_age, max_age));
  gl.bindBuffer(gl.ARRAY_BUFFER, buffers[0]);
  gl.bufferData(gl.ARRAY_BUFFER, initial_data, gl.STREAM_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, buffers[1]);
  gl.bufferData(gl.ARRAY_BUFFER, initial_data, gl.STREAM_DRAW);

  /* Set up VAOs */
  for (var i = 0; i < vao_desc.length; i++) {
    setupParticleBufferVAO(gl, vao_desc[i].buffers, vao_desc[i].vao);
  }

  gl.clearColor(0.0, 0.0, 0.0, 1.0);

  /* Create a texture for random values. */
  var rg_noise_texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, rg_noise_texture);
  gl.texImage2D(gl.TEXTURE_2D,
                0,
                gl.RG8,
                512, 512,
                0,
                gl.RG,
                gl.UNSIGNED_BYTE,
                randomRGData(512, 512));
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

  /* Set up blending */
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  return {
    particle_sys_buffers: buffers,
    particle_sys_vaos: vaos,
    read: 0,
    write: 1,
    particle_update_program: update_program,
    particle_render_program: render_program,
    num_particles: initial_data.length / 6,
    old_timestamp: 0.0,
    rg_noise: rg_noise_texture,
    total_time: 0.0,
    born_particles: 0,
    birth_rate: particle_birth_rate,
    gravity: gravity,
    origin: [0.0, 0.0],
    min_theta: min_theta,
    max_theta: max_theta,
    min_speed: min_speed,
    max_speed: max_speed
  };
}


/* Gets called every frame.
   `gl' shall be a valid WebGL 2 context
   `state' is shall be the state of the particle system
   `timestamp_millis' is the current timestamp in milliseconds
   */
   function render(gl, state, timestamp_millis) {
  var num_part = state.born_particles;

  /* Calculate time delta. */
  var time_delta = 0.0;
  if (state.old_timestamp != 0) {
    time_delta = timestamp_millis - state.old_timestamp;
    if (time_delta > 500.0) {
      /* If delta is too high, pretend nothing happened.
         Probably tab was in background or something. */
      time_delta = 0.0;
    }
  }

  /* Here's where birth rate parameter comes into play.
     We add to the number of active particles in the system
     based on birth rate and elapsed time. */
  if (state.born_particles < state.num_particles) {
    state.born_particles = Math.min(state.num_particles,
                    Math.floor(state.born_particles + state.birth_rate * time_delta));
  }
  /* Set the previous update timestamp for calculating time delta in the
     next frame. */
  state.old_timestamp = timestamp_millis;

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.useProgram(state.particle_update_program);

  /* Most of the following is trivial setting of uniforms */
  gl.uniform1f(
    gl.getUniformLocation(state.particle_update_program, "u_TimeDelta"),
    time_delta / 1000.0);
  gl.uniform1f(
    gl.getUniformLocation(state.particle_update_program, "u_TotalTime"),
    state.total_time);
  gl.uniform2f(
    gl.getUniformLocation(state.particle_update_program, "u_Gravity"),
    state.gravity[0], state.gravity[1]);
  gl.uniform2f(
    gl.getUniformLocation(state.particle_update_program, "u_Origin"),
    state.origin[0],
    state.origin[1]);
  gl.uniform1f(
    gl.getUniformLocation(state.particle_update_program, "u_MinTheta"),
    state.min_theta);
  gl.uniform1f(
    gl.getUniformLocation(state.particle_update_program, "u_MaxTheta"),
    state.max_theta);
  gl.uniform1f(
    gl.getUniformLocation(state.particle_update_program, "u_MinSpeed"),
    state.min_speed);
  gl.uniform1f(
    gl.getUniformLocation(state.particle_update_program, "u_MaxSpeed"),
    state.max_speed);
  state.total_time += time_delta;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, state.rg_noise);
  gl.uniform1i(
    gl.getUniformLocation(state.particle_update_program, "u_RgNoise"),
    0);

  /* Bind the "read" buffer - it contains the state of the particle system
    "as of now".*/
  gl.bindVertexArray(state.particle_sys_vaos[state.read]);

  /* Bind the "write" buffer as transform feedback - the varyings of the
     update shader will be written here. */
  gl.bindBufferBase(
    gl.TRANSFORM_FEEDBACK_BUFFER, 0, state.particle_sys_buffers[state.write]);

  /* Since we're not actually rendering anything when updating the particle
     state, disable rasterization.*/
  gl.enable(gl.RASTERIZER_DISCARD);

  /* Begin transform feedback! */
  gl.beginTransformFeedback(gl.POINTS);
  gl.drawArrays(gl.POINTS, 0, num_part);
  gl.endTransformFeedback();
  gl.disable(gl.RASTERIZER_DISCARD);
  /* Don't forget to unbind the transform feedback buffer! */
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);

  /* Now, we draw the particle system. Note that we're actually
     drawing the data from the "read" buffer, not the "write" buffer
     that we've written the updated data to. */
  gl.bindVertexArray(state.particle_sys_vaos[state.read + 2]);
  gl.useProgram(state.particle_render_program);
  gl.drawArrays(gl.POINTS, 0, num_part);

  /* Finally, we swap read and write buffers. The updated state will be
     rendered on the next frame. */
  var tmp = state.read;
  state.read = state.write;
  state.write = tmp;

  // console.log(Math.floor(player.velocity.length * 100000) )
  // player.position.angle = player.position.angle + .001;
  player.velocity.length += gamepad.dpad1[1] * -1 * 0.0001;
  player.velocity.angle += gamepad.dpad1[0] * -1 * 0.05;
  player.position.addTo(player.velocity);

  state.min_theta = player.velocity.angle - Math.PI - 0.5;
  state.max_theta = player.velocity.angle - Math.PI + 0.5;
  state.origin = [player.position.x, player.position.y];
  // state.num_particles = 100000;
  // state.num_particles = Math.min(Math.floor(player.velocity.length * 100000) + 1000, 1000);

  /* This just loops this function. */
  window.requestAnimationFrame(function(ts) { render(gl, state, ts); });
}


var state =
      init(
        gl,
        1000, /* number of particles */
        0.5, /* birth rate */
        1.01, 1.1, /* life range */
        Math.PI/2.0 - 0.5, Math.PI/2.0 + 0.5, /* direction range */
        0.001, 1, /* speed range */
        [0.0, 0.0]); /* gravity */

    window.state = state;

    /* Makes the particle system follow the mouse pointer */
    // canvas.onmousemove = function(e) {
    //   var x = 2.0 * (e.pageX - this.offsetLeft)/this.width - 1.0;
    //   var y = -(2.0 * (e.pageY - this.offsetTop)/this.height - 1.0);
    //   state.origin = [x, y];
    // };

    window.requestAnimationFrame(
      function(ts) { render(gl, state, ts); });


    // const vertexShader = createShader(gl.VERTEX_SHADER, v_shader);
    // const fragmentShader = createShader(gl.FRAGMENT_SHADER, f_shader);
    // const program = createProgram(vertexShader, fragmentShader);

    // gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    // gl.clearColor(0.0, 0.0, 0.0, 1.0);
    // gl.clear(gl.COLOR_BUFFER_BIT);
    // gl.useProgram(program);
    // gl.drawArrays(gl.POINTS, 0, 1);

    // const Node = { x: null, y: null, neighbours: null }
    // const create = (x, y) => Object.assign(Object.create(Node), { x, y });

    // const graph = create(10,10);
    // graph.neighbours = [ create(9,11),  create(10,12), create(12, 11), create(12, 13) ];
    // graph.neighbours[0].neighbours = [ create(9,13) ];

    // const draw = node => {
    //   const a = 2 * Math.PI / 6;
    //   const r = 10;
    //   const x = node.x * 2 * r;
    //   const y = node.y * 2 * r;


    //   ctx.beginPath();
    //   ctx.arc(x, y, r, 0, Math.PI * 2);
    //   ctx.strokeStyle = "#0005";
    //   ctx.stroke();
    //   ctx.closePath();
    // }

    // let stack = [ graph ];
    // while (stack.length) {
    //   const node = stack.pop();
    //   draw(node);
    //   console.log(node);
    //   if (node.neighbours) {
    //     node.neighbours.forEach(n => {
    //       ctx.beginPath();
    //       ctx.moveTo(node.x * 20, node.y * 20);
    //       ctx.strokeStyle = "#0005";
    //       ctx.lineTo(n.x * 20, n.y * 20);
    //       ctx.stroke();
    //       ctx.closePath();
    //     });

    //     stack.push(...node.neighbours);
    //   }
    // }
  </script>

</body>
</html>
